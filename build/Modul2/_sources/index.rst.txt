Уграђене функције
=================

Појам функције
--------------
	   
**Функције** су један од основних појмова математике и
програмирања. Оне представљају пресликавања одређених улазних
вредности (каже се параметара, аргумената) у једну или више излазних
вредности тј. резултата. На пример, функција може да као улазни
параметар добије дужину странице једнакостраничног троугла :math:`а` и
да као резултат врати дужину обима тог троугла :math:`3\cdot a`. Таква
зависност би се у математици описала као :math:`f(a) = 3\cdot a` што
значи да функција коју смо назвали `f` (што је најчешће име за
функцију) на основу датог параметра :math:`а` одређује вредност
:math:`3\cdot a`. Слично, функција која израчунава обим правоугаоника
на основу дужине његових страница би се у математици описала као
:math:`g(a, b) = 2\cdot a + 2 \cdot b`. У овом случају је функцији дат
назив :math:`g`, она има два улазна параметра (:math:`a` и :math:`b`)
и враћа резултат који је одређен формулом :math:`2\cdot a + 2 \cdot
b`.

Касније ћемо видети како можемо дефинисати функције у језику Python, а
започетак ћемо се само позабавити коришћењем неких основних уграђених
функција (оне су већ дефинисане језиком и можемо их слободно користити
тј. позивати у нашим програмима). У наставку ћемо детаљније описати
следеће функције:

- ``min``, ``max`` - минимум и максимум
- ``abs`` - апсолутна вредност
- ``math.pow``, ``math.sqrt`` -  степен, квадратни корен
- ``round``, ``math.floor``, ``math.ceil`` - заокругљивање реалних
  бројева
  
Минимум и максимум
------------------

У многим задацима потребно је одредити мањи или већи од два дата
броја. Пошто је тај задатак веома чест, програмски језик Python нуди
решење у виду функција ``min`` и ``max``. На пример, вредност израза
``min(2, 5)`` је мањи од бројева 2 и 5 тј. број 2 (тај израз
представља позив функције ``min`` са аргументима ``2`` и ``5``), док
је вредност израза ``max(2, 5)`` већи од бројева 2 и 5 тј. број 5 (тај
израз представља позив функције ``max`` са аргументима ``2`` и ``5``).

.. fillintheblank:: fill_минимум
		    
      Вредност израза ``min(24, 17)`` је |blank|

      -     :17: Тачно!
            :x: Нетачно. min означава мањи број

.. mchoice:: mchoice_минимум
   :answer_a: 2
   :answer_b: 3
   :answer_c: 5
   :correct: a
   :feedback_a: Тачно!
   :feedback_b: min означава мањи од два броја.
   :feedback_c: min означава мањи од два броја. 
		
   Која је вредност израза ``min(min(5, 2), 3)``?

Минимум и максимум неколико бројева могуће је израчунати тако што се
сви наведу као параметри функција `min` тј. `max`. На пример, вредност
израза ``max(3, 2, 5, 4)`` је ``5``.

Покажимо сада неколико задатака у чијем нам решењу ове функције могу
помоћи.

Апсолутна вредност
------------------

Још једна веома корисна функција коју си упознао/упознала у математици
је апсолутна вредност. Апсолутном вредношћу се одређује одступање
броја од нуле.  На пример, број 4 одступа од нуле за 4, док број -5
одступа од нуле за 5 јединица. Дакле апсолутна вредност броја
:math:`x`, која се, подсетимо се обележава са :math:`|x|`, једнака
самом броју :math:`x` ако је :math:`x \geq 0` тј.  броју :math:`-x`,
ако је :math:`x < 0`.

У језику Python апсолутну вредност можемо израчунати помоћу функције
``abs``. Тако је вредност израза ``abs(5)`` једнака ``5``, док је
вредност израза ``abs(-3)`` једнака 3.

.. fillintheblank:: fill_апсолутна_вредност
		    
      Вредност израза ``abs(-11.2)`` је |blank|

      -     :11.2: Тачно!
            :x: abs означава апсолутну вредност броја и она не може бити негативна


Једна од најзначајнијих примена апсолутне вредности је да се израчуна
удаљеност бројева, без обзира на њихов међусобни однос. Наиме,
растојање између бројева :math:`x_1` и :math:`x_2` је једнако
апсолутној вредности њихове разлике тј. вредности :math:`|x_1 - x_2|`,
без обзира да ли је :math:`x_1 \geq x_2` или је :math:`x_1 <
x_2`.


Остале математичке функције
---------------------------
.. level:: 3

Поред ових које смо видели, језик Python 3 нуди многе друге корисне
функције за рад са бројевима. На пример, функција ``round`` заокружује
дати реални број на најближи цео број.

.. dragndrop:: round
    :feedback: Покушај поново
    :match_1: round(2.1)|||2
    :match_2: round(2.9)|||3
    :match_3: round(4.5)|||5

    Превлачењем упари изразе са њиховим вредностима.

Слично, функција ``math.ceil`` заокружује дати реалан број навише
тј. на најмањи цео број већи или једнак њему, док ``math.floor``
заокружује дати реалан број наниже тј. на највећи цео број мањи или
једнак њему. На пример, ``math.ceil(2.1)`` је ``3``, исто као и
``math.ceil(2.9)``, док је ``math.floor(2.1)`` једнако ``2``, исто као
и ``math.floor(2.9)``. Приметимо да имена ових функција почињу са
``math``. Оне су део такозване математичке библиотеке и да би се могле
користити у програму на његовом почетку мора бити написано ``import
math``.

.. fillintheblank:: fill14121
		
      Вредност ``math.ceil(7.25)`` је |blank|  
      Вредност ``math.floor(7.25)`` је |blank|  

      -     :8: Taчно!
            :x: размисли који је најмањи цео број који је већи или једнак 7,25
      -     :7: Taчно!
            :x: Размисли који је највећи цео број који је мањи или једнак 7,25


Функција ``math.sqrt`` израчунава квадратни корен тј. онај ненегативан
број који када се помножи сам са собом (када се квадрира) даје полазни
број. На пример, важи да је :math:`2 \cdot 2 = 4`, тако да је
квадратни корен броја :math:`4` број :math:`2` (то се у математици
записује као :math:`\sqrt{4} = 2`.

Функција ``math.pow`` врши степеновање. На пример, :math:`2^{8} = 256`
се може израчунати помоћу ``math.pow(2, 8)``. Као што множење означава
узастопно сабирање, тако степеновање означава узастопно множење. Други
степен броја :math:`2` je :math:`2^2 = 2 \cdot 2 = 4`, трећи степен
броја :math:`2` је :math:`2^3 = 2 \cdot 2 \cdot 2 = 8` и тако даље.
Поменимо и да је степен дефинисан и када аргументи нису цели бројеви,
али се тиме нећемо бавити. Степеновање се може израчунати и оператором
``**``. Тако се уместо ``math.pow(2, 8)`` може употребити израз ``2 **
8`` чија је вредност такође ``256``.

Осим функција, у библиотеци ``math`` дефинисане су и разне корисне
константе. На пример, број :math:`\pi` који представља однос пречника
и обима круга доступан је помоћу ``math.PI`` (вредност тог броја је
око :math:`3,141592`).

Дефинисање функција
===================

Видели смо колико је корисно када на располагању имамо дате функције
попут ``min``, ``max`` или ``abs``. Сви програмски језици, па и Python
допуштају корисницима да дефинишу своје функције.

У програмима са корњача-графиком смо се срели са дефинисањем
**процедура**, што нам је омогућило да проширимо језик који корњача
разуме и да лакше пишемо програме. Једном када се дефинише процедура,
практично нема разлике између њеног коришћења и коришћења неке од
уграђених наредби, тако да су нам процедуре заправо дале начин да
дефинишемо нове, сложеније наредбе корњачи. **Функције** су веома
сличне процедурама, са главном разликом да функције служе да на основу
улазних вредности израчунају неки резултат и врате га, док процедуре
служе да промене стање програма и обично не враћају никакав резултат.
На пример, `abs` је функција која на основу дате вредности броја
одређује његову апсолутну вредност, док је `kvadrat(a)` процедура која
не враћа никакву вредност већ наређује корњачи да нацрта квадрат на
екрану. `input`, коју смо користили за учитавање са тастатуре је
функција (јер враћа унету вредност), док је `print` процедура (јер не
враћа никакву вредност, већ мења стање програма тј. оно што је
исписано на екрану).

.. infonote::

   Јасна подела на процедуре и функције уведена је у програмском
   језику Pascal. У Python-у се за обе врсте потпрограма користи иста
   кључна реч ``def``, па се стога често не прави разлика између ова
   два облика потпрограма, већ се говори о функцијама које враћају и
   функцију које не враћају вредности.


Функције са више резултата
--------------------------
У неким ситуацијама функција треба да врати више вредности. На пример,
желимо да претварање центиметара у метре и центиметре опишемо у облику
посебне функције. Резултат тада можемо вратити у облику пара или торке
елемената (више речи о паровима и торкама је дато у поглављу о
представљају података у програмима).

.. activecode:: функција_конверзије_дужине

   def cm_u_mcm(cm):
       return (cm // 100, cm % 100)

   (m, cm) = cm_u_mcm(178)
   print(178, "cm", "=", m, "m", "i", cm, "cm")
   (m, cm) = cm_u_mcm(161)
   print(161, "cm", "=", m, "m", "i", cm, "cm")


Сврха дефинисања функција
-------------------------

Резимирајмо на крају неколико основних разлога за дефинисање функција.

- Увођењем функција добијају се разумљивији програми (ономе ко чита
  главни програм много је јасније да се у неком делу израчунава обим
  правоугаоника ако у програму види израз ``obim_pravougaonika(2, 5)``
  него ако види израз ``2 * 2 + 2 * 5)``). Када дефинишемо погодне
  функције, главни програм је било много лакше написати.

- Функције помажу да се програм скрати тако што се избегава понављање
  истог програмског кода (ако је тај програмски код дугачак и
  компликован, издвајање у функцију може значајно поједноставити и
  скратити програм). Ако се покаже да је тај део кода често потребно
  мењати (што је често случај у програмирању) то што се код јавља само
  једном (у склопу тела функције) чини одржавање много једноставнијим
  (не морамо измене да правимо на пуно места, већ само на једном).

- Функције помажу и да се неки проблеми реше, тако што омогућавају
  разлагање комплексних проблема на једноставније потпроблеме.


Наредбе гранања
---------------

У животу често неке ствари радимо само ако је неки услов испуњен. На
пример, ако пада киша, тада ћемо понети кишобран. Ако је наша висина
већа од 140 cm, тада ће нас пустити да се спуштамо низ водени тобоган
у аква-парку. И у програмирању се одређене наредбе извршавају само ако
неки услов испуњен. Да би се описало условно извршавање неких наредби
користи се наредба ``if`` коју смо већ сретали у програмима са Карелом
и корњачом и која у језику Python има следећи облик:

.. activecode:: if_синтакса

   if uslov:           # ако је услов испуњен:
       naredba_1       #     изврши наредбу 1
       ...             #     ...
       naredba_k       #     изврши наредбу k

Реч `if` на енглеском језику значи `ако`.
      
Подсетимо се да се након услова обавезно мора навести двотачка
(карактер ``:``) и да се наредбе које се извршавају условно морају
мало увући (обично се то уради тако што се испред сваке наредбе
откуцају три размака).
      
Често се јавља и потреба да се у зависности од тога да ли је услов
испуњен изврши једна или друга група наредби. На пример, ако је
корисник унео исправну лозинку треба му пожелети добродошлицу на сајт,
а у супротном му треба јавити да унета лозинка није исправна. Такав
облик организације извршавања програма се постиже наредбом ``if-else``
који у језику Python има следећи облик:

.. activecode:: if_else_синтакса

   if uslov:        # ако је услов испуњен: 
       naredba_1    #   изврши наредбу 1
       ...          #   ...
       naredba_m    #   изврши наребу m
   else:            # у супротном: 
       naredba_1    #   изврши наредбу 1
       ...          #   ...
       naredba_n    #   изврши наредбу n

Реч `else` на енглеском језику значи `u suprotnom`.
      
Приметимо да је двотачку потребно навести и иза ``else``, као и да су
оба блока наредби увучена.

Наредбом ``if-else`` ток програма се раздваја на две могућности (могу
се извршити наредбе испод ``if`` или испод ``else``), па се каже да се
ток програма на том месту **грана**, а наредба ``if-else`` назива се
наредба гранања.

Поређење (релацијски оператори)
-------------------------------
      
Најједноставнији облик услова је поређење неких величина. Рачунар уме
да пореди величине (бројеве, али и ниске). За то се користе оператори
слични онима које сте већ видели у математици:

- ``a < b`` проверава да ли је ``a`` мање од ``b``
- ``a > b`` проверава да ли је ``a`` веће од ``b``
- ``a >= b`` проверава да ли је ``a`` веће или једнако ``b``
- ``a <= b`` проверава да ли је ``a`` мање или једнако ``b``
- ``a == b`` проверава да ли је ``a`` једнако ``b``
- ``a != b`` проверава да ли је ``a`` различито од ``b``

Резултат примене ових операција је *тачно* или *нетачно* (кажемо да је
резултат логичка тј. истинитосна вредност).
  
Илуструјмо сада примену гранања и поређења кроз неколико једноставних
програма.


      
Комбиновање више логичких услова (логички оператори)
----------------------------------------------------

Једноставнији услови се могу комбиновати. На пример, учитељица жели да
поклони књигу свим оним ученицима који нису правили проблеме у владању
током године и који су били одлични ђаци или су учествовали у
украшавању учионице. Једноставније услове комбинујемо обично речима
**и**, **или** и **не**. Приметимо да је претходна реченица облика *не
услов1 и (услов2 или услов3)*, где је *услов1* услов да је ученик
правио проблеме, *услов2* да је био одличан ђак, а *услов3* да је
учествовао у украшавању учионице.

- Да би услов облика *услов1 и услов2* био испуњен морају бити
  испуњена оба услова *услов1* и *услов2*. На пример, да би реченица
  *грмило је и севало* била тачна, потребно је да је грмило и да је
  севало. Приметимо да реч *и* на неки начин одговара пресеку скупова
  о којем сте сигурно пуно учили из математике. Реч *и* се у језику
  Python записује помоћу речи ``and``.
- Да би услов облика *услов1 или услов2* био испуњен довољно је да је
  један од услова *услов1* и *услов2* буде испуњен. На пример,
  реченица "ићи ћу за викенд у позориште или у биоскоп" је тачна ако
  одеш само у позориште, само у биоскоп, али и ако одеш и у позориште
  и у биоскоп (постоји посебан облик "или-или" који забрањује да су
  оба услова испуњена, али њега нећемо детаљније разматрати). Реч
  *или* се у језику Python записује помоћу речи ``or``.
- Да би услов облика *не услов* био испуњен услов *услов* не сме бити
  испуњен. На пример, реченица "Данас не пада киша" је тачна само ако
  реченица "Данас пада киша" није тачна. Реч *не* се у језику Python
  записује помоћу речи ``not``.

Веома често је потребно проверити да ли се број налази у неком
интервалу (на пример, време је најпријатније ако је температура између
20 и 25 степени, тј. ако припада интервалу :math:`[20, 25]`). То се
ради тако што се провери да је вредност већа од доње границе интервала
и да је мања од горње границе интервала. 

.. infonote::

   Често је нејасно да ли се границе интервала припадају интервалу или
   не.  На пример, када кажемо између 20 и 25 степени, није јасно да
   ли ту подразумевамо и 20 и 25 степени, или не. Да би се разјаснило
   да ли крај припада интервалу користе се различите врсте
   заграда. Мале заграде (заграде ()) означавају отворене интервале
   којима крајеви не припадају, док средње заграде (заграде [])
   означавају завтворене интервале који садрже и своје крајеве.  На
   пример, интервал :math:`[20, 25]` садржи и вредности 20 и 25,
   интервал :math:`(20, 25)` их не садржи, док интервал :math:`[20,
   25)` садржи вредност 20, али не и 25. Са оваквим полуотвореним
   интервалима смо се већ срели код индексирања ниски и листа
   (подсетимо се, ``str[a:b]`` издваја све карактере из ниске са
   позиција из интервала :math:`[a, b)`, тј. карактере који почињу на
   позицији ``a``, а завршавају се на позицији стриктно испред ``b``).

Конструкција elif
-----------------

Прикажимо употребу конструкције ``elif`` кроз следећи задатак.

Агрегатно стање воде
''''''''''''''''''''
.. level:: 2

.. questionnote::

   Напиши програм који за дату температуру воде (у степеним Целзијуса)
   одређује њено агрегатно стање (сматраћемо да је вода у чврстом
   стању ако јој је температура строго мања од 0, да је у течном ако
   јој је температура између 0 и 100 степени, укључујући и те границе
   и да је у гасовитом стању ако јој је температура строго већа од 100
   степени).

.. image:: ../../_images/stanje-vode.png
   :height: 300px   
   :align: center
   

На основу услова задатка може се формирати програм у којем се помоћу
три провере услова независно проверава припадност температуре једном
од три интервала :math:`(-\infty , 0]`, :math:`(0, 100)` и
:math:`[100, \infty)`.

.. activecode:: агрегатно_стање_1

   temperatura = 15

   if temperatura < 0:
       stanje = "cvrsto"
   if temperatura >= 0 and temperatura <= 100:
       stanje = "tecno"
   if temperatura > 100:
       stanje = "gasovito"

Међутим, решење се може креирати и ако размишљамо на следећи начин
(тако да логички услови буду међусобно зависни):

- ако температура мања од :math:`0^{\circ}\,C` - агрегатно стање је
  чврсто;
- у противном (температура је већа или једнака :math:`0^{\circ}\,C`):
  ако је температура мања или једнака :math:`100^{\circ}\,C` (припада
  другом интервалу) - агрегатно стање je течно;
- у противном (температура је већа :math:`100^{\circ}\,C`) агрегатно
  стање је гасовито.

Такво постпуно проверавање услова се остварује помоћу **конструкције**
``elif``.
  
.. activecode:: агрегатно_стање_2
		
   temperatura = 15
   
   if temperatura < 0:
       stanje = "cvrsto"
   elif temperatura <= 100:
       stanje = "tecno"
   else:
       stanje = "gasovito"

   print(stanje)

У општем случају, општи облик ове конструкције је следећи:

.. activecode:: elif

   if uslov_1:
       naredbe
   elif uslov_2:
       naredbe
   ...
   elif uslov_k:
       naredbe
   else:
       naredbe

Прва група наредби се извршава ако је први услов испуњен, друга ако
први није испуњен а други јесте, трећа ако прва два услова нису
испуњена, а трећи јесте и тако даље, све до последње групе наредби
која се извршава ако ниједан од наведених услова није
испуњен. Приметимо да се увек извршава тачно један блок наредби у
наведеном коду.

Приметимо да је срж следећег задатка била у томе да се одреди којем од
неколико надовезаних интервала припада дата вредност (то су били
интервали :math:`(-\infty, 0)`, :math:`[0, 100]` и :math:`(100,
+\infty)`). Задаци тог облика су чести и када је таквих интервала
мало, обично се решавају конструкцијом ``elif``.

Понављање
##################

У програмима често имамо потребе да се одређена наредба или блок
наредби понове више пута. У програмима са Карелом и корњачом упознали
смо се са коришћењем петљи `for` и `while`. У овом поглављу видећемо
како се ове петље могу користити у конзолним програмима.


Понављање наредби дати број пута
--------------------------------

Размислимо како бисмо написали програм који десет пута исписује
``Zdravo``.  На основу онога што смо до сада научили можемо десет пута
навести наредбу ``print("Zdravo")``.

.. activecode:: здраво_десет_пута_1

   print("Zdravo")
   print("Zdravo")
   print("Zdravo")
   print("Zdravo")
   print("Zdravo")
   print("Zdravo")
   print("Zdravo")
   print("Zdravo")
   print("Zdravo")
   print("Zdravo")

Приметимо да је овај програм било напорно откуцати (чак иако смо
користили технику копирања и лепљења). Ако сада замислимо да желимо да
корисник прво унесе број колико пута жели да се испише поздрав, тада
је јасно да тај програм не можемо испрограмирати на овај начин, већ су
нам потребне мало напредније технике програмирања. Решење долази у
облику *петљи*, тј. наредби које омогућавају да се нека наредба или
неки блок наредби понове више пута. За почетак размотримо наредбу
којом постижемо да се нешто понови дати број пута. Најједноставнији
начин да то урадимо је да употребимо наредбу облика ``for i in
range(n):``. Наредни програм 10 пута исписује поруку ``Zdravo``,
коришћењем петље ``for``.

.. activecode:: здраво_десет_пута
		
   for i in range(10):        # ponovi 10 puta:
       print("Zdravo")        #    ispiši tekst "Zdravo"

Након петље можемо исписати и додатну поруку (у овом примеру то је
порука ``Zbogom``).

.. activecode:: здраво_десет_пута_2
		
   for i in range(10):        # ponovi 10 puta:
       print("Zdravo")        #    ispiši tekst "Zdravo"
   print("Zbogom")         # ispiši tekst "Zbogom"

Приметимо да је испис поруке ``Zdravo`` био увучен, јер се понавља,
док испис поруке ``Zbogom`` није био увучен јер се не понавља више
пута. Ако бисмо увукли обе наредбе исписа, онда би се обе понављале 10
пута, што није оно што желимо.

.. activecode:: здраво_десет_пута_3
		
   for i in range(10):        # ponovi 10 puta:
       print("Zdravo")        #    ispiši tekst "Zdravo"
       print("Zbogom")     #    ispiši tekst "Zbogom"

   
Увежбајмо овај облик понављања кроз још неколико једноставних примера.
      
Обими 5 троуглова
'''''''''''''''''
.. level:: 1
      
.. questionnote::

   Напиши програм који израчунава обиме пет једнакостраничних
   троуглова чије дужине страница корисник уноси.

.. activecode:: обими_пет_троуглова
		
   for i in range(5):                                # ponovi 5 puta:
       a = int(input("Unesi duzinu stranice:"))      #   ucitaju duzinu stranice
       O = 0                                         #   izracunaj obim - ispravi ovaj red
       print(O)                                      #   ispiši obim

Приметимо да су све наредбе у телу петље увучене у односу на петљу,
али и да су међусобно поравнате, што мора увек бити случај (у
супротном се добија порука да програм није исправан).
      
Поздрави сваког ученика
'''''''''''''''''''''''
.. level:: 1
      
.. questionnote::

   Напиши програм који учитава неколико имена ученика и сваког
   појединачно поздравља. 

.. activecode:: поздрав_ученицима
   
   n = int(input("Unesi broj ucenika: "))           # ucitaj broj ucenika n
   for ???:                                         # ponovi n puta: 
       ime = input("Kako se zoveš?")                #    unesi ime ucenika - ispravi ovaj red
       print("Zdravo, ti se zoveš:", ime)           #    pozdravi ucenika

Примети да овај пут уместо константне вредности унутар ``range`` треба
навести променљиву ``n``, што значи да ће се петља извршавати различит
број пута (у зависности од броја ``n`` који корисник уноси). Такође,
примети да променљива ``ime`` не чува број него текст. Приликом уноса
вредности употребили смо само ``input(...)``, а не
``int(input(...))``, нити ``float(input())``, јер након уноса текста
није потребно из њега прочитати ни целобројну ни реалну бројевну
вредност (чему служе функције ``int`` и ``float``).
      
Опсег бројева - ``range``
-------------------------

Размотримо сада детаљније како функционише петља ``for i in
range(n):`` којом смо постизали да се нешто понови ``n`` пута.  Током
извршавања такве петље променљива ``i`` редом узима вредности ``0``,
``1``, ``2`` итд., све до вредности ``n-1``. На пример, ако је ``n``
једнако ``3``, тада ће се тело петље извршити пет пута и у првом
извршавању тела петље променљива ``i`` ће имати вредност ``0``, у
другом вредност ``1``, а у трећем вредност ``2``. Позив ``range(n)``,
дакле, формира колекцију бројева ``0, 1, 2, ..., n-1`` из које затим
бројачка променљива ``i`` узима редом једну по једну вредност.  Осим
са једним, функцију ``range`` могуће је позвати и са два и са три
параметра. Када се наведу два аргумента ``a`` и ``b``, врши се
набрајање свих елемената из интервала целих бројева ``[a, b-1]``, док
се у случају када се наведу три аргумента ``a``, ``b`` и ``k`` врши
набрајање сваког ``k``-тог елемента тог интервала. Дакле,

- позив ``range(n)`` гради колекцију ``1, 2, ..., n-1``;
- позив ``range(a, b)`` гради колекцију ``a, a+1, ..., b-1``;
- позив ``range(a, b, k)`` гради колекцију ``a, a+k, a+2k, ...,
  a+nk``, где је последњи број одабран тако да буде последњи у овом
  низу који је строго мањи од ``k``.

Провери да ли ово разумеш тако што ћеш одговорити на наредних неколико
питања.
  
.. mchoice:: console__collections_quiz_range1_srp
   :answer_a: range(4)
   :answer_b: range(1, 4)
   :answer_c: range(3)
   :answer_d: range(1, 3)
   :correct: b
   :feedback_a: Покушај поново
   :feedback_b: Тачно
   :feedback_c: Покушај поново
   :feedback_d: Покушај поново

   Који опсег садржи вредности 1, 2, 3 ?

.. mchoice:: console__collections_quiz_range2_srp
   :answer_a: 5
   :answer_b: 6
   :answer_c: 9
   :answer_d: 10
   :correct: a
   :feedback_a: Тачно
   :feedback_b: Покушај поново
   :feedback_c: Покушај поново
   :feedback_d: Покушај поново

   Колико вредности садржи опсег ``range(1, 10, 2)`` ?

Испис бројева од a до b
'''''''''''''''''''''''
.. level:: 1

Када се у позиву функције ``range`` наведе само један аргумент, онда
бројање креће од нуле, међутим, када се наведу два аргумента ``a`` и
``b``, тада бројање креће од ``a`` и завршава се са ``b-1``.

.. questionnote::

   Напиши програм који учитава два броја ``a`` и ``b`` и затим
   исписује све бројеве од ``a`` до ``b`` (укључујући и њих).

.. activecode:: бројеви_од_a_до_b
		
   a = int(input("Odakle se broji: "))
   b = int(input("Dokle se broji: "))		
   for i in range(0, 0):    # ispravi ovaj red
       print(i)